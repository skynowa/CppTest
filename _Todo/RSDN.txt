/**
 * \file  main.cpp
 * \brief
 *
 * \todo
 */


1. Что определяет класс? Чем обличается класс от объекта?
2. Можно ли объявлять массив объектов? А массив классов?
3. Разрешается ли объявлять указатель на объект? А указатель на класс?
4. Допускается ли передавать объекты в качестве параметров, и какими способами?
А возвращать как результат?
5. Как называется использование объекта одного класса в качестве поля другого
класса?
6. Является ли структура классом? Чем класс отличается от структуры?
7. Какие ключевые слова в С++ обозначают класс?
8. Объясните принцип инкапсуляции.
9. Что такое композиция?
10. Для чего используются ключевые слова public и private?
11. Можно ли использовать ключевые слова public и private в структуре?
12. Существуют ли ограничения на использование public и private в классе? А в
структуре?
13. Обязательно ли делать поля класса приватными?
14. Что такое метод? Как вызывается метод?
15. Может ли метод быть приватный?
16. Как определить метод непосредственно внутри класса? А вне класса? Чем эти
определения отличаются?
17. Можно в методах присваивать параметрам значения по умолчанию?
18. Что обозначается ключевым словом this?
19. Зачем нужны константные методы? Чем отличается определение константного
метода от обычного?
20. Может ли константный метод вызываться для объектов-переменных? А обычный
метод — для объектов-констант?
21. Объясните принцип полиморфизма.
22. Сколько места в памяти занимает объект класса? Как это узнать?
23. Каков размер «пустого» объекта?
24. Влияют ли методы на размер объекта?
25. Одинаков ли размер класса и аналогичной структуры?
26. Какие операции нельзя перегружать? Как вы думаете, почему?
27. Можно ли перегружать операции для встроенных типов данных?
28. Можно ли при перегрузке изменить приоритет операции?
29. Можно ли определить новую операцию?
30. Перечислите особенности перегрузки операций как методов класса. Чем
отличается перегрузка внешним образом от перегрузки как метода класса?
31. Какой результат должны возвращать операции с присваиванием?
32. Как различаются перегруженная префиксная и постфиксная операции инкремента и
декремента?
33. Что означает выражение *this? В каких случаях оно используется?
34. Какие операции не рекомендуется перегружать как методы класса? Почему?
35. Какие операции разрешается перегружать только как методы класса?
36. Дайте определение дружественной функции. Как объявляется дружественная
функция? А как определяется?
37. Дайте определение конструктора. Каково назначение конструктора? Перечислите
отличия конструктора от метода.
38. Сколько конструкторов может быть в классе? Допускается ли перегрузка
конструкторов? Какие виды конструкторов создаются по умолчанию?
39. Может ли конструктор быть приватным? Какие последствия влечет за собой
объявление конструктора приватным?
40. Приведите несколько случаев, когда конструктор вызывается неявно.
41. Как проинициализировать динамическую переменную?
42. Как объявить константу в классе? Можно ли объявить дробную константу?
43. Каким образом разрешается инициализировать константные поля в классе?
44. В каком порядке инициализируются поля в классе? Совпадает ли этот порядок с
порядком перечисления инициализаторов в списке инициализации конструктора?
45. Какие конструкции С++ разрешается использовать в списке инициализации
качестве инициализирующих выражений?
46. Какой вид конструктора фактически является конструктором преобразования
типов?
47. Для чего нужны функции преобразования? Как объявить такую функцию в классе?
48. Как запретить неявное преобразование типа, выполняемое конструктором
инициализации?
49. Какие проблемы могут возникнуть при определении функций преобразования?
50. Для чего служит ключевое слово explicit?
51. Влияет ли наличие целочисленных констант-полей на размер класса?
52. Разрешается ли объявлять массив в качестве поля класса. Как присвоить
элементам массива начальные значения?
53. Сколько операндов имеет операция индексирования []? Какой вид результата
должна возвращать эта операция?
54. Для чего нужны статические поля в классе? Как они определяются?
55. Как объявить в классе и проинициализировать статический константный массив?
56. Что такое выравнивание и от чего оно зависит? Влияет ли выравнивание на
размер класса?
57. Дайте определение контейнера.
58. Какие виды встроенных контейнеров в С++ вы знаете?
59. Какие виды доступа к элементам контейнера вам известны?
60. Чем отличается прямой доступ от ассоциативного?
61. Перечислите операции, которые обычно реализуются для последовательного
доступа к элементам контейнера.
62. Дайте определение итератора.
63. Можно ли реализовать последовательный доступ без итератора? В чем
преимущества реализации последовательного доступа с помощью итератора?
64. Что играет роль итератора для массивов С++?
65. Что такое деструктор? Может ли деструктор иметь параметры?
66. Почему для классов-контейнеров деструктор надо писать явным образом?
67. Допускается ли перегрузка деструкторов?
68. Что такое «глубокое копирование» и когда в нем возникает необходимость?
69. Какое копирование осуществляет стандартный конструктор копирования?
70. Чем отличается копирование от присваивания?
71. Объясните, почему в операции присваивания требуется проверка присваивания
самому себе?
72. Можно ли в качестве операции индексирования использовать операцию вызова
функции ()? В чем ее преимущества перед операцией []?
73. Почему необходимо писать два определения операции индексирования? Чем они
отличаются?
74. Дайте определение вложенного класса.
75. Можно ли класс-итератор реализовать как внешний класс? А как вложенный? В
чем отличия этих методов реализации?
76. Может ли объемлющий класс иметь неограниченный доступ к элементам вложенного
класса? А вложенный класс — к элементам объемлющего?
77. Ограничена ли глубина вложенности классов?
78. Можно ли определить вложенный класс внешним образом? Зачем это может
понадобиться?
79. Каким образом вложенный класс может использовать методы объемлющего класса?
А объемлющий — методы вложенного?
80. Что такое «запредельный» элемент, какую роль он играет в контейнерах?
81. Объясните, по каким причинам трудно написать универсальный контейнер,
элементы которого могут иметь произвольный тип.
82. Назовите ключевые слова С++, которые используются для обработки исключений.
83. Исключение — это:
1) событие;
2) ситуация;
3) объект;
4) ошибка в программе;
5) прерывание;
84. Каким образом исключение генерируется?
85. Каковы функции контролируемого блока?
86. Что обозначается ключевым словом catch?
1) контролируемый блок;
2) блок обработки исключения;
3) секция-ловушка;
4) генератор исключения;
5) обработчик прерывания;
87. Какого типа может быть исключение?
88. Сколько параметров разрешается писать в заголовке секции-ловушки?
89. Какими способами разрешается передавать исключение в блок обработки?
90. Объясните, каким образом преодолеть ограничение на передачу единственного
параметра в блок обработки.
91. Почему нельзя выполнять преобразования типов исключений при передаче в
секцию-ловушку?
92. Напишите конструкцию, которая позволяет перехватить любое исключение.
93. Могут ли контролируемые блоки быть вложенными?
94. Зачем нужен «контролируемый блок-функция» и чем он отличается от обычного
контролируемого блока?
95. Перечислите возможные способы выхода из блока обработки.
96. Каким образом исключение «передать дальше»?
97. Сколько секций-ловушек должно быть задано в контролируемом блоке?
98. Что такое «спецификация исключений»?
99. Что происходит, если функция нарушает спецификацию исключений?
100. Учитывается ли спецификация исключений при перегрузке функций?
101. Что такое «иерархия исключений»?
102. Существуют ли стандартные исключения? Назовите два-три типа стандартных
исключений.
103. Поясните «взаимоотношение» исключений и деструкторов.
104. Объясните, зачем может понадобиться подмена стандартных функций завершения.
105. Какие виды нестандартных исключений вы знаете?
106. В чем отличие механизма структурной обработки исключений Windows от
стандартного механизма?
107. Какие две роли выполняет наследование?
108. Какие виды наследования возможны в С++?
109. Чем отличается модификатор доступа protected от модификаторов private и
public?
110. Чем открытое наследование отличается от закрытого и защищенного?
111. Какие функции не наследуются?
112. Сформулируйте правила написания конструкторов в производном классе.
113. Каков порядок вызова конструкторов? А деструкторов?
114. Можно ли в производном классе объявлять новые поля? А методы?
115. Если имя нового поля совпадает с именем унаследованного, то каким образом
разрешить конфликт имен?
116. Что происходит, если имя метода-наследника совпадает с именем базового
метода?
117. Сформулируйте принцип подстановки.
118. Когда выполняется понижающее приведение типов?
119. Объясните, что такое «срезка» или «расщепление».
120. Объясните, зачем нужны виртуальные функции.
121. Что такое связывание?
122. Чем «раннее» связывание отличается от «позднего»?
123. Какие два вида полиморфизма реализованы в С++?
124. Дайте определение полиморфного класса.
125. Может ли виртуальная функция быть дружественной функцией класса?
126. Наследуются ли виртуальные функции?
127. Каковы особенности вызова виртуальных функций в конструкторах и
деструкторах?
128. Можно ли сделать виртуальной перегруженную операцию, например, сложение?
129. Может ли конструктор быть виртуальным? А деструктор?
130. Как виртуальные функции влияют на размер класса?
131. Как объявляется «чистая» виртуальная функция?
132. Дайте определение абстрактного класса.
133. Наследуются ли чистые виртуальные функции?
134. Можно ли объявить деструктор чисто виртуальным?
135. Чем отличается чистый виртуальный деструктор от чистой виртуальной функции?
136. Зачем требуется определение чистого виртуального деструктора?
137. Наследуется ли определение чистой виртуальной функции?
138. Приведите классификацию целей наследования.
139. Объясните разницу наследования интерфейса от наследования реализации.
140. Назовите причины, требующие разделения программ на части.
141. Дайте определение термина «единица трансляции»?
142. Чем отличается файл с исходным текстом от единицы трансляции?
143. Существуют ли в С++ конструкции, позволяющие идентифицировать отдельный
модуль?
144. Какие способы сборки программы вы можете назвать?
145. Что такое «объектный модуль»? Программа, которая «собирает» объектные
модули в программу, называется _____________ ?
146. В чем заключается отличие аргумента «файл» от <файл> в директиве #include?
147. Что такое ODR?
148. Объясните, что такое «страж» включения и зачем он нужен.
149. Является ли интерфейс класса его определением?
150. Сколько определений класса может быть в единице трансляции?
151. Сколько определений класса может быть в многофайловой программе?
152. Чем отличаются стандартные заголовки <string>, <string.h> и <cstring>?
153. Объясните суть идиомы Pimpl.
154. Что такое делегирование и как его можно использовать для повышения степени
инкапсуляции?
155. Каким образом глобальную переменную, определенную в одной единице
трансляции, сделать доступной в другой единице трансляции? А константу?
156. Можно ли использовать слово extern при объявлении функций?
157. Как локализовать объявление функции в файле?
158. Чем отличается «внешнее» связывание от «внутреннего» связывания?
159. Что такое «спецификации компоновки»?
160. Какие объекты обладают внутренним связыванием по умолчанию?
161. Какие области видимости имен вы знаете?
162. Для чего используются пространства имен?
163. Чем отличаются именованные и неименованные пространства имен?
164. Могут ли пространства имен быть вложенными?
165. Для чего применяются алиасы пространства имен?
166. Как сделать члены пространства имен доступными в нескольких (в пределе — во
всех) файлах программного проекта?
167. Объясните разницу между статической и динамической инициализацией.
168. В чем состоит проблема инициализации глобальных статических переменных?
169. Какие элементы класса можно объявлять статическими?
170. Можно ли объявить в классе статическую константу? А константный статический
массив?
171. А какие статические поля можно инициализировать непосредственно в классе?
172. Как определяются статические поля? В какой момент работы программы
выполняется инициализация статических полей?
173. Сколько места в классе занимают статические поля ?
174. Чем отличается статический метод от обычного?
175. Какие методы класса не могут быть статическими?
176. Какие применения статических полей вы можете привести? А каким образом
применяются статические методы?
177. Приведите структуру и принцип действия паттерна Singleton.
178. Для чего предназначены шаблоны?
179. Какие виды шаблонов в С++ вы знаете?
180. Объясните термин «инстанцирование шаблона».
181. В чем разница между определением и объявлением шаблона?
182. Объясните назначение ключевого слова typename.
183. Какие виды параметров разрешается задавать в шаблоне класса? А в шаблоне
функции?
184. Можно ли параметрам шаблона присваивать значения по умолчанию?
185. Может ли параметром шаблона быть другой шаблон? Каковы особенности
объявления параметра-шаблона?
186. Что такое специализация шаблона? Объясните разницу между полной и частичной
специализацией.
187. Разрешается ли специализировать шаблон функции?
188. Может ли класс-шаблон быть вложенным в другой класс-шаблон? А в обычный
класс?
189. Можно ли объявить в классе шаблонный метод? А шаблонный конструктор?
190. Можно ли перегружать функцию-шаблон?
191. Какие параметры функции-шаблона выводятся автоматически?
192. Может ли шаблон класса быть наследником обычного класса? А обычный класс от
шаблона?
193. Объясните, что такое класс свойств (класс трактовок).
194. Каким образом можно использовать возможность наследования обычного класса
от шаблона?
195. Может ли шаблонный конструктор быть конструктором по умолчанию?
196. Для чего применяются директивы явного инстанцирования?
197. Объясните, в чем состоят проблемы, возникающие при разделении шаблонного
класса на интерфейс и реализацию?
198. Что такое «модель явного инстанцирования» и как она работает?
199. Может ли шаблонный класс иметь «друзей»?
200. Какие проблемы возникают при объявлении дружественной функции для класса-шаблона?
201. Разрешается ли определять в классе-шаблоне статические поля? А статические
методы?
202. Что такое «инициализация нулем»?
203. Что является единицей памяти в С++? Какие требования к размеру единицы
памяти прописаны в стандарте С++?
204. В каких единицах выдает результат операция sizeof? Какие типы данных имеют
размер 1?
205. Какие три вида памяти входят в модель памяти С++?
206. Сколько видов динамической памяти обеспечивает С++?
207. Какие функции для работы с динамической памятью достались С++ по наследству
от С? В какую библиотеку они включены?
208. Какие функции выделяют память, и с помощью каких функций память
освобождается?
209. Какое важное отличие имеет функция calloc() от функции malloc()?
210. Какие действия выполняют функции выделения памяти, если память не может
быть выделена?
211. Зависит ли объем выделенной памяти от типа указателя? Влияет ли
выравнивание на объем выделяемой динамической памяти?
212. Можно ли с помощью функции realloc() уменьшить объем выделенной памяти?
213. Что произойдет, если функции free() передать в качестве аргумента нулевой
указатель?
214. В чем главное отличие объектно-ориентированного механизма new/delete от
механизма malloc()/free()?
215. Сколько существует форм new/delete? В чем их отличие?
216. Какие типы являются POD-типами? Чем отличается работа механизма new/delete
с POD-объектами и nonPOD-объектами?
217. Какие функции выполняет обработчик new?
218. Можно ли реализовать собственный обработчик new и «прицепить» его к
механизму new/delete?
219. В чем главное отличие объединения от других видов классов С++?
220. Может ли объединение участвовать в иерархии наследования?
221. Разрешается ли определять для объединения конструкторы и деструктор? А
виртуальные функции?
222. В чем похожи и чем отличаются объединение и размещающий new?
223. Объясните, почему при использовании размещающего new нужно явным образом
вызывать деструктор?
224. Зачем нужны интеллектуальные указатели?
225. Что такое «стратегия владения»? Сколько стратегий владения вы знаете?
226. Какой интеллектуальный указатель реализован в стандартной библиотеке STL, и
какую стратегию владения он реализует?
227. Объясните, в чем преимущества и недостатки интеллектуальных указателей со
счетчиком ссылок.
228. Разрешается ли перегружать new и delete и какими способами?
229. Опишите схему функции, перегружающей глобальную функцию new.
230. Отличается ли реализация перегруженной функции new[]() для массивов от
реализации «обычной» функции new()?
231. Как вы думаете, почему функции new/delete, перегружаемые для класса,
являются статическими?
232. Зачем при перегрузке new/delete для класса нужно проверять размер
запрашиваемой памяти?
233. Объясните, чем определяется «динамичность» контейнеров?
234. Что такое «стратегия распределения памяти», и какие стратегии выделения
памяти вы знаете?
235. Рассмотрите следующую стратегию распределения памяти: память выделяется для
нескольких элементов блоками фиксированной длины, но блоки связываются в список.
Для какого вида контейнера можно использовать такую стратегию?
236. Какие операции можно перегрузить для доступа к элементам двумерного массива?
237. В чем заключаются сложности использования операции индексирования [] для
доступа к элементам двумерного массива?
238. Каковы способы реализации операций с контейнерами?
239. Какую конструкцию можно назвать «обобщенный алгоритм»?
240. Каким образом объявить указатель на метод?
241. Объясните разницу между указателем на функцию и указателем на метод.
242. Каким образом получить адрес метода?
243. Можно ли указателю на функцию присваивать адрес метода?
244. Какие операции определены в С++ для косвенного вызова метода через
указатель?
245. Что такое «функтор»? Приведите пример функционального класса.
246. Какими способами функтор вызывается?
247. Можно ли использовать наследование при разработке функторов?
248. Разрешается ли операцию вызова функции () определять как виртуальный метод?
А как статический?
249. В чем преимущества функторов перед указателями на функции?
250. Объясните, зачем нужны адаптеры функторов? Какие виды адаптеров вы знаете?
251. Как используются классы свойств при разработке функторов?
252. Объясните, что такое «композиция» и приведите примеры?
253. Объясните, чем отличается множественное наследование от простого?
254. Приведите структуру и принцип действия паттерна Adapter.
255. Сформулируйте основную проблему множественного наследования.
256. Выполняется ли принцип подстановки при открытом множественном наследовании?
257. Что такое виртуальное наследование? Каковы его преимущества и недостатки по
сравнению с обычным наследованием?
258. Может ли виртуальное наследование быть одиночным?
259. Влияет ли виртуальное наследование на размер класса?
260. Объясните, каким образом с помощью виртуального наследования можно вообще
запретить наследование.
261. Какие средства С++ составляют RTTI?
262. Объясните разницу между повышающим, понижающим и перекрестным приведением.
263. Какими свойствами должен обладать класс, чтобы с ним работал механизм RTTI?
264. В чем приведение указателей отличается от приведения ссылок?
265. Какие исключения связаны с механизмом RTTI?
266. Что такое «поток» — дайте определение.
267. Как классифицируются потоки, реализованые в библиотеках ввода/вывода С++?
268. Что такое буферизация и зачем она нужна?
269. Какие библиотеки ввода/вывода реализованы в С++ и чем они отличаются?
270. Перечислите стандартные потоки и объясните их назначение.
271. Зачем нужен процесс форматирования и когда он выполняется?
272. Что такое «форматная строка», и в каких функциях она используется?
273. Объясните назначение элементов спецификатора формата.
274. Сколько спецификаторов формата может быть в форматной строке?
275. Какой из элементов спецификатора формата не является умалчиваемым?
276. Перечислите несколько известных вам обозначений типов в спецификаторе
формата, и укажите их назначение.
277. Сколько модификаторов типа вы знаете, и какую роль модификатор типа играет
в спецификаторе формата?
278. С помощью какого флага можно выровнять выводимое значение влево? А каким
образом вывести ведущие нули?
279. Какое действие оказывают на выводимую строку ширина, точнойть и флаги в
спецификаторе формата?
280. Для чего в спецификаторе формата может использоваться символ звездочка
(«*»)? Чем отличается действие этого символа при воде и при выводе?
281. Каковы особенности ввода строк?
282. Каким образом ограничить набор вводимых символов при вводе?
283. Что является главной проблемой при использовании форматного ввода/вывода из
библиотеки <cstdio>?
284. Объясните, для чего нужны строковые потоки. Почему строковые потоки —всегда
форматируемые?
285. С помощью каких функций выполняется работа со строковыми потоками?
286. Можно ли использовать тип string (и каким образом) со строковыми потоками?
287. Объясните, в чем заключается различие между текстовым и двоичным файлом.
288. Объясните, что означает «открыть» файл и «закрыть» файл?
289. Каким образом внешний файл связывается с потоком?
290. Можно ли один и тот же поток связать с разными файлами? А один и тот же
файл с разными потоками?
291. Перечислите режимы открытия файла. Чем отличается режим “r” от режима “a”?
292. Какую роль в режиме открытия играет знак плюс («+»)?
293. В каких случаях необходимо следить за ситуацией «конец файла»? Каким
способом это делается?
294. Можно ли текстовый файл открыть как двоичный? А двоичный — как текстовый?
295. Какие функции ввода/вывода используются для обмена с текстовыми файлами?
296. Перечислите функции ввода/вывода для работы с двоичными файлами.
297. Какие функции реализованы в библиотеке <cstdio> для обеспечения прямого
доступа к записям двоичного файла? Можно ли их использовать для работы с
текстовыми файлами?
298. Объясните назначение функции fseek().
299. Чем отличается функция ftell() от функции fgetpos()?
300. Объясните, что означает «перенаправление» потока? Какие потоки можно
перенаправлять и куда?
301. Каким образом перенаправление ввода можно использовать для ввода строк с
пробелами?
302. В чем преимущества объектно-ориентированной библитеки по сравнению с
процедурной?
303. В каких состояних может находиться поток? Каким образом отслживается
состояние «конец потока»?
304. Какие объектно-ориентированные потоки связаны со стандартными потоками?
305. Чем отличаются объектно-ориентированные строковые потоки от процедурных
строковых потоков?
306. Каким образом строковые потоки можно использовать для ограничения ширины
поля ввода? А можно ли с той же целью использовать строковые потоки <cstdio>?
307. Сравните средства форматирования объектно-ориентированной и процедурной
библиотеки.
308. Каким образом ввести строку типа string с пробелами?
309. Каково назначение флагов форматированя? Какие средства реализованы в
библиотеке для работы с флагами форматирования?
310. Что такое «манипулятор»? В чем преимущества манипуляторов перед флагами
форматирования?
311. Как связываются файлы с потоками в объектно-ориентированной библиотеке?
312. Можно ли файлы, записанные функциями библиотеки <cstdio>, прочитать
объектно-ориентированными средствами? А наоборот?
313. Перечислите режимы открытия объектно-ориентированных файловых потоков.
каким образом комбинируются режимы открытия файлоавых потоков?
314. Обязательно ли закрывать файл, связанный с объектно-ориентированным
файловым потоком? А открывать?
315. Каким образом открыть файловый поток для чтения и записи одновременно?
316. Как открыть файловый поток для дозаписи?
317. Можно ли вывести значение переменной в двоичном виде и как это сделать?
318. Разрешается ли наследовать от классов библиотеки ввода/вывода?
319. Каким образом можно еренаправить объектно-ориентированный поток?
320. Как используется буфер потока для копирования потока?
321. Какими операциями выполняется форматированный ввод/вывод в файловые потоки?
А неформатированный?
322. Реализованы ли в объектно-ориентированной библиотеке средства прямого
доступа к файловым потокам? Сравните их с аналогичными средствами библиотеки <cstdio>.
323. С какими объектно-ориентированными потоками разрешается, и с какими не
разрешается использовать средства прямого доступа?
324. Покажите, каким образом можно выполнить перегрузку операций ввода/вывода
для нового типа данных.
325. Как выполняется обработка ошибок ввода/вывода в объектно-ориентированной
библиотеке?
326. Какое стандартное исключение генерируется при ошибках ввода/вывода?
Обязательно ли оно генерируется?
327. Чем стандартные широкие потоки отличаются от узких?
328. Что такое — «локаль», и каково ее назначение?
329. Как установить русский шрифт при выводе в консольное окно?
330. Чем отличается ли ввод/вывод широких файловых потоков от узких?
331. Перечислите все последовательные контейнеры стандартной библиотеки. Чем они
отличаются друг от друга?
332. Перечислите адаптеры последовательных контейнеров и дайте их подробную
характеристику.
333. Почему для адаптеров-очередей нельзя использовать вектор в качестве
базового?
334. Чем простая очередь queue отличается от приоритетной очереди priority_queue?
335. Каким требованиям должны удовлетворять элементы контейнера?
336. Могут ли быть указатели элементами контейнера? А итераторы?
337. Почему нельзя использовать в качестве элементов контейнера стандартный
интеллектуальный указатель auto_ptr?
338. Зачем в контейнере list реализованы собственные методы сортировки поиска и
слияния? Можно ли пользоваться соответствующими стандартными алгоритмами при
обработке списка?
339. Перечислите типовые виды конструкторов, с помощью которых можно создавать
последовательный контейнер.
340. Можно ли инициализировать контейнер элементами встроенного массива? А
элементами другого контейнера? Какими способами это можно сделать?
341. Почему конструктор инициализации, параметрами которого являются итераторы,
сделан шаблонным во всех контейнерах?
342. Какие методы реализованы в контейнере-векторе для доступа к элементам?
343. Отличается ли функция at() доступа по индексу от перегруженной операции
индексирования и чем?
344. Перечислите методы контейнера deque, относящиеся к определению размеров
контейнера.
345. Чем метод size() отличается от метода capacity()? А в чем отличие этих
методов от метода max_size()?
346. Перечислите методы контейнера list, предназначенные для вставки удаления и
замены элементов. Отличаются ли эти методы от соответствующих методов вектора и
дека?
347. Каким образом выполняются операции сравнения контейнеров?
348. Разрешается ли изменять элемент ассоциативного контейнера, доступный в
данный момент по итератору?
349. Какие контейнеры называются ассоциативными и почему?
350. Чем контейнер map отличается от контейнера multimap?
351. Объясните, почему в ассоциативных контейнерах нельзя изменять элемент,
доступный в данный момент по итератору.
352. По каким причинам в контейнере-множестве не реализованы типовые операции
объединения, пересечения, разности и другие?
353. Как используется структура-пара в ассоциативных контейнерах?
354. Объясните, что такое «критерий сортировки», и каким требованиям он должен
удовлетворять? Какой критерий сортировки принят по умолчанию?
355. Какими преимуществами обладает функция make_pair() по сравнению с
конструктором pair()?
356. Почему в контейнерах-отображениях операция индексирования перегружена, а в
контейнерах-множествах — нет?
357. Какие гарантии безопасности обеспечивают контейнеры стандартной библиотеки?
358. Что такое «транзакционная гарантия безопасности» и чем она отличается от
базовой?
359. На какие 4 класса по надежности можно разделить все операции с контейнерами?
360. Что такое «распределитель памяти» и зачем он нужен?
361. Чем отличается битовый вектор bitset от битового вектора vector<bool>?
362. Дайте определение итератора.
363. Что такое «начальный» итератор и «конечный» итератор? Какие методы,
связанные с итераторами, обязательно включает каждый контейнер?
364. Чем константный итератор отличается от неконстантного?
365. Объясните, что такое «недействительный» итератор. В каких случаях итераторы
становятся недействительными?
366. Какие категории итераторов вы знаете? Какие операции обязательно
реализуются для всех категорий итераторов?
367. К какому виду итераторов можно отнести встроенный указатель и почему?
368. Какие вспомогательные функции для итераторов вы знаете? В каких случаях
оправдано их применение?
369. Какие адаптеры итераторов реализованы в библиотеке?
370. Объясните, почему итераторы реализованы как вложенные классы в контейнерах.
371. Чем отличаются итераторы вставки от обычных итераторов?
372. Каким образом используются потоковые итераторы?
373. Какие стандартные функторы реализованы в библиотеке STL? Каково их основное
назначение?
374. Для чего нужны адаптеры функторов bind1st() и bind2nd()?
375. Как применяются адаптеры-отрицатели?
376. Почему алгоритмы remove() не удаляют элементы из контейнеров? Как реально
удалить элементы из контейнера?
377. Чем отличается стабильная сортировка от обычной?
378. Какую функцию выполняет алгоритмы unique()?
379. Могут ли стандартные алгоритмы работать со строками?
380. Нужно ли сортировать ассоциативные контейнеры?
381. Можно ли алгоритмы для работы с множествами применять для последовательных
контейнеров? При каких условиях?
382. Какие алгоритмы предназначены для заполнения контейнера значениями? С
какими контейнерами они могут работать?
383. Каким образом заполнить с помощью алгоритма generate() последовательный
контейнер, не имеющий ни одного элемента?
384. Перечислите алгоритмы, предназначенные для операций с каждым элементом
контейнера.
385. Можно ли с помощью алгоритма for_each() изменить элементы контейнера?



1. Что такое инкапсуляция?
 2. Что такое полиморфизм? Виды полиморфизма? Чем задаются?
 3. Что такое наследование?
 4. Как задать функцию без параметров?
 5. Что будет разделителем для строки cin>>? (Напр. для «Один два»).
 6. Требуется ли явно указывать тип возвращаемого значения в return?
 7. Как определить булев тип?
 8. Как надо задавать включаемые библиотечные файлы в С++? Как использовать заголовочные файлы из C?
 9. Как задать пространство имен в котором определены все библиотечные функции С++?
 10. Как перегрузить функцию? Как это связано с полиморфизмом?
 11. Какие функции нельзя перегрузить?
 12. Описать варианты наследования базового класса и к каким членам в каждом случае будет иметь доступ наследник?
 13. Структура программы на С++?
 14. Что такое класс и что такое объект?
 15. Какие члены класса не могут иметь инициализатор? (с. 254)
 16. Какие ключевые слова нельзя использовать при объявлении членов класса?
 17. Может ли объявление класса включать в себя его объект или указатель на его объект?
 18. Когда имеет смысл объявлять переменные класса открытыми?
 19. 2 отличия между структурами и классами?
 20. Что такое POD? Какие признаки у POD?
 21. Как определить класс с помощью слова union? Будет ли у него конструктор и деструктор? Какие особенности имеют его члены? Какой уровень доступа такой класс будет иметь по умолчанию? (с. 256)
 22. 2 ограничения наложенных на такие классы?
 23. Чего не могут содержать такие классы (4 случая)?
 24. Как осуществляется доступ к членам безымянного объединения?
 25. Чего не может содержаться в безымянных объединениях (2 случая)?
 26. Как объявить глобальное безымянное объединение?
 27. Когда могут быть особенно полезны дружественные функции (3 случая)? Как их объявить? К каким членам класса они имеют доступ? Можно ли сделать ее доступной просто в проге (использовать 2-ой прототип)?
 28. Что такое неполное объявление класса?
 29. Может ли дружественная функция быть членом другого класса?
 30. Как это записать?
 31. Ограничения на дружественные функции (2 случая)? (с. 261)
 32. Может ли класс быть дружественным?
 33. К каким типам данных он будет иметь доступ?
 34. Можно ли через дружественный класс узнать значение данных из класса которому он дружественен? Через его объект? Как это записывается?
 35. Что гарантирует применение слова inline?
 36. Какие функции компилятор может запретить подставлять?
 37. Какие есть варианты определения inline функций в классе?
 38. Способы объявлений объектов у которых конструктор класса принимает параметры (2 варианта)?
 39. В чем особенность создания объектов класса у которого конструктор с одним параметром?
 40. В чем особенности статических членов класса?
 41. Чем инициализируются статические переменные-члены класса по умолчанию и когда это происходит?
 42. В чем особенность задания статических переменных-членов класса?
 43. Как правильно их задавать?
 44. Особенности статических функций-членов (5 случаев)? (с. 271) Какие варианты перегрузки возможны?
 45. Можно ли присваивать значения статическим переменным класса до создания объектов этого класса?
 46. Когда вызываются конструкторы глобальных объектов?
 47. Когда вызываются деструкторы глобальных объектов?
 48. Как обратиться к глобальной переменной, если в функции определена локальная переменная с таким же именем?
 49. Можно ли определить один класс внутри другого?
 50. Можно ли определить класс внутри функции?
 51. Какие ограничения накладываются на локальные классы (3 случая)? (с. 275)
 52. Сколько раз будет вызываться конструктор и деструктор объекта, если его один раз передавали функции по значению?
 53. Какие могут возникнуть проблемы при передаче объекта в функцию по значению?
 54. Может ли функция возвращать объект?
 55. Что будет в этом случае возвращаться и какие могут возникнуть проблемы?
 56. Можно ли присваивать объекты друг другу?
 57. В каких случаях можно использовать сокращенную форму инициализации массива объектов?
 58. Как выглядит полная форма инициализации массива объектов?
 59. О чем надо помнить создавая массив неинициализированных объектов?
 60. Можно ли присвоить указателю адрес какого-либо члена объекта?
 61. Что передается практически любой функции класса? Каким функциям это не передается (2 случая)? (с. 285)
 62. На какие члены производного класса можно ссылаться с помощью базового типа указателя?
 63. Как получить доступ к остальным членам производного класса?
 64. Особенности адресной арифметики ввиду динамического полиморфизма?
 65. Что такое указатель на член класса?
 66. Его синтаксис?
 67. Пример использования?
 68. Синтаксис использования ссылки?
 69. Что будет: int y = 8; int &s = y; s++;?
 70. Может ли функция стоять в левой части оператора присваивания? Когда это возможно?
 71. Что происходит с объектом которого вернули по ссылке после завершения работы вернувшей его функции?
 72. Что такое независимая ссылка?
 73. Когда можно присваивать значение ссылке?
 74. Можно ли присваивать ссылке на базовый класс объекты производных классов?
 75. Ограничения на ссылки (4 случая)?
 76. Что происходит если new не смог выделить требуемую память?
 77. 3 причины почему new, delete лучше malloc, free? (с. 297)
 78. Как проинициализировать память выделяемую new?
 79. Как с помощью new выделить память для массива?
 80. Как для массива правильно вызывать delete?
 81. Как проинициализировать объект созданный с помощью new?
 82. Как проинициализировать массивы созданные с помощью new?
 83. Что нужно помнить о классах, размещая динамически массивы их объектов?
 84. Заголовочный include для new?
 85. Как записать new возвращающий нулевой указатель в случае неудачи распределения памяти?
 86. Буферизованный new?
 87. Является ли это перегрузкой функции: void f (int* p); void f (int p[]);?
 88. Является ли это перегрузкой функции: void f(int a); и void f(const int a);? void f(int a); & void f(unsigned int a);? void f(int a); & void f(int &a);?
 89. Форма записи конструктора копирования? Пример перегрузки?
 90. 3 случая когда может использоваться конструктор копирования для присваивания?(с. 308)
 91. Вызывается ли здесь конструктор копирования: A a; B b; a = b;?
 92. Как создать указатель на функции: void f (int a. float f); void f (int a);?
 93. Где можно задать параметры по умолчанию для функции?
 94. Можно ли создать конструктор с параметрами заданными по умолчанию?
 95. Неоднозначность (2 случая)?
 96. Общий вид операторной функции-члена?
 97. Как перегрузить + чтобы можно было написать (ob.a + ob.b).show();? Когда разрушится объект в скобках?
 98. Примеры перегрузок -, =, ++x, x++, +=?
 99. Ограничения налагаемые на перегруженные операторы (3 случая)?
 100. Какие операторы нельзя перегружать (4 экземпляра)?
 101. Какие перегруженные операторы наследуются производными классами, а какие нет? Можно ли их перегрузить в производном классе?
 102. Как перегрузить оператор с помощью дружественной функции?
 103. Какие операторы нельзя перегрузить с помощью дружественных функций (4 штуки)?
 104. Как перегрузить операторы x++, ++x с помощью дружественных функций?
 105. Как перегрузить оператор сложения объекта с числом?
 106. Примеры перегрузки new и delete?
 107. Примеры перегрузки new и delete для массивов?
 108. Перегрузка new и delete без генерирования исключительной ситуации?
 109. Какие ограничения есть на перегрузку (), [], -> (2 случая)?
 110. Пример перегрузки []?
 111. Пример перегрузки ()?
 112. Пример перегрузки ->?
 113. Пример перегрузки ,?
 114. Какие виды доступа при наследовании бывают и как при этом трактуются данные различных видов доступа из базового класса в производном?
 115. Форма записи при множественном наследовании?
 116. Порядок вызова конструкторов и деструкторов в производном классе? Если он использовал множественное наследование?
 117. Как передать параметры конструктору базового класса?
 118. Правило объявления переменных базового класса в конструкторе производного?
 119. 2 Способа повысить уровень доступа к членам базового класса? На все ли члены базового класса это распространяется?(с. 360)
 120. Как повысить уровень доступа к функции базового класса?
 121. Неоднозначность при множественном наследовании?
 122. 2 способа обойти ее?
 123. А если d1 virtual наследует, а d2 нет?
 124. Форма записи виртуального наследования?
 125. Виды полиморфизма? На чем основаны?
 126. Можно ли в классе-наследнике написать реализацию виртуальной функции с другим числом параметров (лишние имеют значения по умолчанию)?
 127. Будет ли работать полиморфизм при использовании ссылок на базовый класс?
 128. 3 ограничения для виртуальных функций?
 129. Наследуется ли атрибут виртуальности функции?
 130. Если в Base virtual f(), d1:B f(), d2:d1, то что будет: Base *p = &d1; p->f(); Base *p = &d2; p->f(); d1 *p1; p1 = &d2; p1->f();?
 131. Принцип иерархичности наследования относительно выбора реализации функции?
 132. Форма объявления чисто виртуальной функции?
 133. Что такое раннее связывание и что такое позднее связывание? Их плюсы и минусы?
 134. Форма записи шаблонных функций?
 135. Как называется конкретная версия шаблонной функции создаваемая компилятором?
 136. Как называется процесс генерации конкретной функции?
 137. Сколько вариантов шаблонной функции генерирует компилятор?
 138. Как явно перегрузить обобщенную функцию (2 варианта)?
 139. Как перегрузить шаблонную функцию?
 140. Пример объявления обобщенного класса и его объекта?
 141. Пример записи объявления функции обобщенного класса и ее реализации?
 142. Можно ли создать реализацию шаблонного класса с пользовательским типом данных?
 143. Пример обобщенного безопасного массива?
 144. То же самое, но с заданием размера этого массива?
 145. Какие типы можно использовать в качестве стандартных параметров для шаблонного класса, функции?
 146. Правила передачи стандартных параметров шаблонного класса?
 147. Пример использования аргументов по умолчанию в шаблонных классах?
 148. Пример явной специализации класса?
 149. 2 случая применения typename?
 150. Использование слова export применительно к шаблонам?
 151. Общий вид операторов try и catch?
 152. Пример try, throw, catch?
 153. Что будет если генерируется исключительная ситуация для которой не предусмотрена обработка?
 154. Пример, когда может генерироваться исключение вне блока try?
 155. Может ли catch располагаться не сразу за try?
 156. Пример использования нескольких catch?
 157. Как надо выполнять перехват исключения описанного с помощью базового и производного типов?
 158. Как ввести перехват всех исключительных ситуаций?
 159. Как можно грамотно его использовать вместе с перехватчиками остальных исключений?
 160. Как запретить функции генерировать исключительные ситуации?
 161. Область действия ограничения функции на исключительные ситуации?
 162. Как повторно сгенерировать исключительную ситуацию?
 163. Какие функции вызываются при неверной обработке исключительной ситуации? И в каких конкретно случаях?
 164. Заголовок для функций terminate & unexpected?
 165. Какие функции вызывают terminate & unexpected?
 166. Как поменять обработчик для функций terminate & unexpected?
 167. Чего не должны делать новые обработчики?
 168. Как узнать перехвачена ли уже сгенерированная исключительная ситуация?
 169. ?Поток. Его принцип деятельности?
 170. 2 основных класса С++ для ввода/вывода?
 171. Высокоуровневая иерархия?
 172. Какие потоки открываются при начале выполнения программы?
 173. 2 способа форматирования данных при вводе/выводе?
 174. 18 флагов fmtflags?
 175. Функция для установки флагов формата?
 176. Можно ли применить ее сразу для всех потоков?
 177. Функция для сброса флагов формата?
 178. Перегруженная форма функции setf()?
 179. Функция для определения текущего состояния флагов форматирования?
 180. Как установить группу флагов?
 181. Функции изменения ширины, точности и символа заполнения?
 182. 32 манипулятора формата?
 183. Заголовок для манипуляторов с параметрами?
 184. Пример перегрузки оператора вставки?
 185. Может ли перегруженная функция вставки быть членом класса?
 186. Как с помощью перегруженной функции вставки вывести закрытые члены класса?
 187. Пример перегрузки оператора извлечения?
 188. Как проверить какой поток вызвал перегруженный оператор извлечения/вставки?
 189. Как создать собственный манипулятор?
 190. Заголовок для реализации файлового ввода / вывода?
 191. Класс для низкоуровневого управления файловым потоком?
 192. Как связать файловый поток с файлом?(2)
 193. Отличие текстового от бинарного режима открытия файла?
 194. Режимы открытия файла?
 195. Режимы открытия по умолчанию?
 196. Как проверить успешность открытия файла?(2)
 197. Функция закрытия файла?
 198. Функции чтения / записи символов для файла?
 199. Как определить закончился ли файл при его чтении?
 200. Функции чтения / записи блоков бинарных данных?
 201. Как записать / считать структуру?
 202. Что будет если конец файла обнаружится раньше чем read считает num символов?
 203. Как определить число считанных символов?
 204. Перегрузки get()?
 205. Отличие get() от getline()?
 206. Функция определения конца файла?
 207. Функция пропуска части символов?
 208. Как считать следующий символ в потоке не извлекая его?
 209. Как вернуть обратно считанный символ?
 210. Как принудительно записать данные из буфера в файл? Когда рекомендуется это делать?
 211. Функции произвольного доступа к файлу?
 212. О чем надо помнить применяя эти функции к текстовым файлам?
 213. Как определить текущую позицию курсоров доступа к файлу?
 214. Как получить информацию о статусе ввода / вывода?(2)
 215. Как сбросить флаги ошибок?
 216. Оператор определения типа объекта и его заголовок?
 217. Функции – члены type_info?
 218. Важное ограничение на typeid() в связи с полиморфизмом?
 219. ? Разыменованный указатель.
 220. Можно ли применять typeid() к ссылкам?
 221. Как проверить является ли объект таким-то типом?
 222. Применение typeid() к шаблонным классам?
 223. 5 операторов приведения типов?
 224. ? оператор динамического приведения типов?
 225. Требование к его результирующему типу?
 226. Для приведения каких типов он предназначен?
 227. Как проверить успешность dynamic_cast?
 228. Тип исключительной ситуации при typeid и dynamic_cast?
 229. Какие типы к каким приводятся dynamic_cast-ом?
 230. Приведение типов с typeid и dynamic_cast?
 231. Можно ли использовать dynamic_cast для шаблонных классов?
 232. Можно ли привести T<int>* к T<double>*?
 233. Как заместить const & volatile? Пример? Пример с ссылкой?
 234. Оператор для неполиморфного приведения?
 235. Проверяет ли он приведение типов?
 236. Как привести разные типы данных?
 237. Общий вид объявления пространства имен?
 238. 2 способа обращения к данным из пространства имен вне его?
 239. Если создать объект класса namespace_name::some_class, нужно ли при его использовании ставить область видимости?
 240. 2 варианта использования using?
 241. ?Неименованное пространство имен. Синтаксис?
 242. Зачем оно нужно?
 243. Можно ли разделить пространство имен?
 244. Пример?
 245. Где можно объявлять пространство имен?
 246. Пример использования вложенного пространства имен?
 247. Как включить только часть функций из std?
 248. ? Функция преобразования класса. Синтаксис?
 249. Пример?
 250. Можно ли задать несколько type()?
 251. Как объявить константную функцию – член и в чем ее особенность?
 252. Как разрешить ей изменять какой-либо член класса?
 253. Функция volatile и ее особенности?
 254. ? Явные конструкторы. Синтаксис?
 255. Как инициализировать константы и ссылки в конструкторе?
 256. Как проинициализировать члены класса, имеющего только конструктор с аргументами, в другом, содержащем его классе?
 257. Порядок создания и инициализации членов класса?
 258. Как вставить код на ассемблере?
 259. Спецификация связей функции? Синтаксис?
 260. В каких местах ее можно объявлять?
 261. Как связать с программой сразу несколько функций?
 262. ? Буферизованный ввод / вывод.
 263. Заголовок для него?
 264. Синтаксис ввода / вывода?
 265. Как узнать сколько символов записано в массив?
 266. Динамический массив вывода? Пример использования?
 267. 9 отличий С от С++?
 268. ? Контейнеры. 2 типа?
 269. ? Алгоритмы.
 270. ? Итераторы. 5 видов?
 271. ? Обратный итератор.
 272. ? Распределитель.
 273. ? Предикат. 2 вида? Специальная разновидность бинарных предикатов?
 274. 2 заголовка STL общего типа (для pair и для функторов)?
 275. ? Функторы. 15 экземпляров? Зачем они нужны?
 276. Еще 2 вида функторов?
 277. ? Адаптер.
 278. 11 контейнеров? Заголовки для них?
 279. Основные переопределенные типы контейнерных классов(12)?
 280. 4 конструктора vector<T>? Пример использования?
 281. Ограничение на объекты, хранящиеся в векторе?
 282. Функции вектора?(20)
 283. Пример вектора с использованием итератора?
 284. На что указывает итератор возвращаемый end()?
 285. В каком месте вставляет элемент insert?
 286. Пример со вставкой и удалением?
 287. Когда можно не перегружать операторы объектов для вектора?
 288. Пример вектора с объектами?
 289. 4 конструктора списка?
 290. 6 операторов определенных в списке?
 291. Основные функции – члены списка?(28)
 292. Что должны иметь объекты, хранящиеся в списке?
 293. Пример вставки одного списка с объектами в другой?
 294. 3 конструктора map?
 295. 6 операторов определенных в map?
 296. Требования к объектам – ключам в map?
 297. Основные функции map?(17)
 298. ? Pair.
 299. Пример с map? Пример с make_pair?
 300. Заголовок для алгоритмов?
 301. Стандартные алгоритмы?
 302. Алгоритмы подсчета элементов? (2) Примеры?
 303. ? remove_copy(). Пример?
 304. ? replace_copy(). Пример?
 305. ? reverse(). Пример?
 306. ? transform().Пример?
 307. ? negate(). Пример?
 308. ? divides().Пример?
 309. Пример создания простого функтора?
 310. 2 биндера для связи аргументов функтора с определенными значениями?
 311. Пример биндеров с remove_it?
 312. 2 негатора?
 313. 3 «за» string?
 314. Главный «против»?
 315. 3 основных конструктора string?
 316. 12 операторов string?
 317. Можно ли в выражениях смешивать string и строки?
 318. 2 варианта функции – члена string для присвоения строк?
 319. 2 варианта функции – члена string для добавления строк?
 320. 2 варианта функции – члена string для вставки строк?
 321. 2 варианта функции – члена string для замены строк?
 322. Функция – член для удаления символов в string?
 323. Функции – члены string для нахождения первого и последнего вхождения подстроки в строку?
 324. Функции – члены string для сравнения строк?
 325. Функции – члены string для создания С – строки?
 326. Можно ли применять к string контейнерные функции?
 327. Можно ли хранить string в контейнерах?


 C++
 -для чего нужен виртуальный деструктор
 -чем отличается вызов виртуального деструктора от обычной виртуальной
 функции
 -чем отличаются const char* ptr и char const *ptr
 -чем чреват выброс исключения из конструктора, деструктора
 -в чем потенциальная опасность конструктора копирования по умолчанию
 -чем отличаются операторы приведения типа static_cast, reinterpret_cast, dynamic_cast, const_cast
 -метод const. класс const. ключевое слово mutable.
 -как определить чисто виртуальную функцию, абстрактный базовый класс
 -как организовать освобождение ресурсов при выходе из функции/метода
 -как запретить создание объектов в куче
 -как предотвратить утечки памяти связанные с с забывчивостью вызывать Delete
 -как запретить удаление объекта класса
 -как запретить наследование от данного класса
 -что такое виртуальный базовый класс (виртуальное наследование)
 -что такое частичная специализация шаблона
 -для чего нужен виртуальный конструктор
 -как удалить массив объектов
 -в каких случаях вызывается конструктор копирования
 -что такое конструктор конверсии. ключевое слово explicit.
 -в каких случаях переменная класса должна быть проинициализирована в списке инициализации конструктора
 -когда класс должен иметь конструктор по умолчанию
 -когда можно вернуть из функции ссылку на локальный объект
 -почему в C++ нельзя реализовать автоматическую сборку мусора?

 STL
 -Как выбрать подходящий для задачи STL-контейнер
 -Что такое функтор. Что такое алгоритм
 -Какие есть способы поиска в контейнерах
 -В чем разница между stack, queue и другими контейнерами
 -Что такое распределители (allocators)

 COM и ATL
 -Что такое апартамент. В чем разница между однопоточным и многопоточным апартаментом.
 -Что такое суррогатный процесс
 -Как передать указатель на интерфейс из одного потока в другой в STA
 -Виды маршалинга , их достоинства и недостатки
 -Какие есть способы передачи массива структур в COM-сервер.
 -Передача блоков данных переменной длины.
 -Кто должен распределять и освобождать память при передаче строк BSTR
 -Как получить на клиенте данные из буфера, распределенного в COM-сервере
 -Как в ATL создать многопоточный объект (MTA)
 -Какой интерфейс в ATL используется для передачи клиенту информации об ошибках?
 -Как организовать передачу callback-вызовов от COM-сервера к клиенту ?


 Win32
 -Как распределяется доступная процессу память
 -Чем отличается семафор от мьютекса
 -Какие средства межпроцессной коммуникации вы знаете, их достоинства и недостатки?
 -Как создать единственный экземпляр приложения в памяти (singleton)
 -Как происходит создание отображаемого в память файла
 -Как передать процессу указатель на память распределенную в другом
 процессе
 -Как сигнализировать другому потоку о его завершении и как дождаться его завершения из вызывающего потока

 Объектно-ориентированное проектирование
 -Что такое полиморфизм
 -Что такое is-a и has-a отношения
 -Знакомы ли вам паттерны проектирования

 Базы данных
 -что такое нормализация
 -свойства 3-й нормальной формы
 -достоинства и недостатки нормализации
 -что такое ссылочная целостность
 -что такое первичный ключ, внешний ключ
 -в чем достоинства и недостатки использования триггеров
 -что такое транзакция. виды изоляции транзакций
 -разрешение конфликтов при одновременном изменении данных


 Объясните разницу между понятиями виртуальная функция и виртуальное наследование .
 Объясните, чем отличаются глобальные статические функции от статических функций, членов классов.
 Что общего, и чем обычно отличаются реализации конструкторов копирования, инициализации и перегруженной операции присваивания?
 Сравните 2 способа перегрузки операций: как метод класса и как внешнюю функцию-друг .
 Как создать в классе виртуальные конструкторы и деструктор?
 Может ли шаблонный (темплэйтный) класс быть абстрактным? Почему?
 В чем специфика перегрузки операций "sizeof", "typeid", "new" и "delete"? Чем она вызвана?
 Сравните особенности перегрузки операций "()" и "[]".
 Дайте развернутое сравнение работы со строками в стиле С (char*) и С++ (string).
 Дайте развернутое сравнение работы с динамической памятью в С и С++.
 Дайте развернутое сравнение стандартных средств ввода-вывода в С и С++.
 Что означает оператор throw без параметра?
 Расскажите, какие бывают итераторы и чем они отличаются.
 В чем различие между модификаторами register, const и volatile?
 Как написать функцию, принимающую заранее неизвестное число аргументов?
 В чем разница между конструкциями "extern" и "extern "C""?
 В чем, в рамках традиционного С++, различие между using и include?
 Сравните использование макросов, inline-функций и template-функций.
 Как грамотно организовать нетривиальную сортировку средствами стандартных библиотек С и С++ (сравните подходы)?
 Расскажите, что и как нужно сделать, что бы объекты написанного Вами класса можно было помещать в cout и читать из cin?
 Сравните различные формы операций приведения типа (в стиле С и в стиле С++). Расскажите о перегрузке этих операций.
 У каждого класса есть некоторые особые функции-члены, вызовы которых могут вставляться компилятором в код без явного на то указания программиста. Перечислите такие функции, члены и случаи, когда могут возникать неявные вызовы.
 Как задать значения аргументов функций по умолчанию? Каковы плюсы и минусы использования этой возможности С++? Каковы ее альтернативы?
 При написании оператора catch мы можем в качестве типа его аргумента написать непосредственно тип исключения, указатель на тип исключения либо ссылку на тип исключения. Сравните эти подходы.
 В каком порядке вычисляются аргументы функции при ее вызове: слева направо, справа налево или еще как-нибудь? Например, в каком порядке будут вычислены аргументы в следующем примере: f(5+I, ++I); ?
 Если при создании переменной программист ее явно не инициализировал, то, в некоторых случаях, компилятор сам даст ей некое, заранее известное начальное значение, а в некоторых случаях начальное значение будет непредсказуемо. От чего это зависит?
 От чего зависит порядок создания (последовательность вызова конструкторов) глобальных переменных? Какие практические выводы из этого следуют?
 Есть код:
 f(){return 3.5;}
 ...
 double d = f()
 Чему равно значение d ? Почему?
 Объясните разницу между понятиями "анонимное пространство имен" и "анонимное перечисление".
 Что произойдет, если исключение будет выброшено изнутри конструктора?
 Что из себя представляет и для чего применяется специализация шаблонов?
 В чем специфика применения операции delete к указателям на функции?
 Что такое и как используется this ?
 Для чего применяется предварительное объявление (forward declaration) классов?
 Какие директивы препроцессора обычно используются для предотвращения повторного включения заголовочного файла?
 Какие конструкции для организации ветвления предоставляет программистам С++?
 Какие конструкции для организации циклов предоставляет программистам С++?
 Что такое полиморфизм? Наличие какие конструкций в С++ позволяет утверждать, что этот язык поддерживает полиморфизм? Для чего используется полиморфизм?
 Что такое lvalue ?
 Для чего в C++ используется ключевое слово finaly ?
 Сравните операторы continue и break.
 Что такое и для чего нужны триграфы?
 В чем отличие и что общее в специфике перегрузки конструкторов и деструкторов?
 Что такое и как используется анонимное объединение?
 Можно ли в С++ (если да — то как) написать такой класс, от которого нельзя пронаследовать в дальнейшем никакой другой класс?
 Даны два класса, один из которых является наследником от второго. Напишите, как должны выглядеть конструкторы копирования-инициализации для этих классов (составьте пример).
 В чем специфика операций || и && ? В чем специфика перегрузки этих операций?
 Сравните понятия "статическая переменная" и "статическая переменная — член класса".
 В чем опасность использования макросов? Приведите примеры.
 Сравните операторы throw и return.
 Как инициализировать переменную, являющуюся приватным статическим членом класса?
 Для чего нужен и как используется класс auto_ptr ?