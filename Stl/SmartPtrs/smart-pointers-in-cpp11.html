<!DOCTYPE html>
<!-- saved from url=(0064)http://archive.kalnitsky.org/2011/11/02/smart-pointers-in-cpp11/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Введение в C++11: умные указатели | kalnitsky's way</title>

  <link rel="shortcut icon" href="http://archive.kalnitsky.org/favicon.ico">
  <link rel="alternate" href="http://archive.kalnitsky.org/feed/index.xml" type="application/atom+xml" title="Atom feed">  <link rel="stylesheet" href="./smart-pointers-in-cpp11_files/style.min.css">  <link rel="canonical" href="http://archive.kalnitsky.org/2011/11/02/smart-pointers-in-cpp11/">

</head><body>

  <div class="header-wrapper">
  <header id="header">
    <img class="logo" alt="logo" src="./smart-pointers-in-cpp11_files/logo.png">
    <h1><a href="http://archive.kalnitsky.org/">kalnitsky's way</a></h1>

    <nav>
<a href="http://archive.kalnitsky.org/projects/">Projects</a><a href="http://archive.kalnitsky.org/about/">About</a><a href="http://archive.kalnitsky.org/feed/">Feed</a>    </nav>
  </header>
  </div> <!-- /.header-wrapper -->

  <div id="content">
  <article>
    <header>
      <time datetime="2011-11-02T00:00:00">02 ноя 2011</time>
      <h1>Введение в C++11: умные указатели</h1>
    </header>

    <div class="entry-content">
      <p>Продолжу доброю традицию и расскажу сегодня об умных указателях, также
известных как Smart Pointers. Умные указатели очень актуальны в мире C++ и
новый стандарт не обошел их стороной.</p>
<p><strong>Smart pointer</strong> — это объект, работать с которым можно как с обычным
указателем, но при этом, в отличии от последнего, он предоставляет некоторый
дополнительный функционал (например, автоматическое освобождение закрепленной
за указателем области памяти).</p>
<p>Умные указатели призваны для борьбы с утечками памяти, которые сложно избежать
в больших проектах. Они особенно удобны в местах, где возникают исключения,
так как при последних происходит процесс раскрутки стека и уничтожаются
локальные объекты. В случае обычного указателя — уничтожится
переменная-указатель, при этом ресурс останется не освобожденным. В случае
умного указателя — вызовется деструктор, который и освободит выделенный
ресурс.</p>
<p>В новом стандарте появились следующие умные указатели: <tt class="docutils literal">unique_ptr</tt>,
<tt class="docutils literal">shared_ptr</tt> и <tt class="docutils literal">weak_ptr</tt>. Все они объявлены в заголовочном файле
<tt class="docutils literal">&lt;memory&gt;</tt>.</p>
<div class="section" id="unique-ptr">
<h2>unique_ptr</h2>
<p>Этот указатель пришел на смену старому и проблематичному <tt class="docutils literal">auto_ptr</tt>. Основная
проблема последнего заключается в правах владения. Объект этого класса теряет
права владения ресурсом при копировании (присваивании, использовании
в конструкторе копий, передаче в функцию по значению).</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y_ptr</span><span class="p">;</span>

<span class="c1">// вот это нехороший и неявный момент
// права владения ресурсов уходят в y_ptr и x_ptr начинает
// указывать на null pointer
</span><span class="n">y_ptr</span> <span class="o">=</span> <span class="n">x_ptr</span><span class="p">;</span>

<span class="c1">// segmentation fault
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">x_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre>
<p>Это очень неудобно, при работе с контейнером из умных указателей. Банальное</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="c1">// ...
</span><span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre>
<p>сделает элемент вектора невалидным. Именно поэтому данный класс не пользовался
популярностью среди разработчиков.</p>
<p>В отличии от <tt class="docutils literal">auto_ptr</tt>, <tt class="docutils literal">unique_ptr</tt> запрещает копирование.</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y_ptr</span><span class="p">;</span>

<span class="c1">// ошибка при компиляции
</span><span class="n">y_ptr</span> <span class="o">=</span> <span class="n">x_ptr</span><span class="p">;</span>

<span class="c1">// ошибка при компиляции
</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">z_ptr</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">);</span>
</pre>
<p>Изменение прав владения ресурсом осуществляется с помощью вспомогательной
функции <tt class="docutils literal"><span class="pre">std::move</span></tt> (которая является частью механизма перемещения).</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y_ptr</span><span class="p">;</span>

<span class="c1">// также, как и в случае с ``auto_ptr``, права владения переходят
// к y_ptr, а x_ptr начинает указывать на null pointer
</span><span class="n">y_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">);</span>
</pre>
<p>Как <tt class="docutils literal">auto_ptr</tt>, так и <tt class="docutils literal">unique_ptr</tt> обладают методами <tt class="docutils literal">reset()</tt>,
который сбрасывает права владения, и <tt class="docutils literal">get()</tt>, который
возвращает <em>сырой</em> (классический) указатель.</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>

<span class="c1">// получаем классический указатель
</span><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">();</span>

<span class="c1">// сбрасываем права владения
</span><span class="n">ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</pre>
<p>Как видно, <tt class="docutils literal">unique_ptr</tt> недалеко ушел от своего предшественника в плане
удобства использования, но, во всяком случае, он обезопасил от неявных смен
прав владений ресурсом.</p>
</div>
<div class="section" id="shared-ptr">
<h2>shared_ptr</h2>
<p>Это самый популярный и самый широкоиспользуемый умный указатель. Он начал
своё развитие как часть библиотеки <a class="reference external" href="http://www.boost.org/">boost</a>. Данный указатель был столь успешным,
что его включили в <a class="reference external" href="http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1">C++ Technical Report 1</a> и он был доступен в пространстве
имен <tt class="docutils literal">tr1</tt> — <tt class="docutils literal"><span class="pre">std::tr1::shared_ptr&lt;&gt;</span></tt>.</p>
<p>В отличии от рассмотренных выше указателей, <tt class="docutils literal">shared_ptr</tt> реализует подсчет
ссылок на ресурс. Ресурс освободится тогда, когда счетчик ссылок на него будет
равен 0. Как видно, система реализует одно из основных правил сборщика мусора.</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>

<span class="c1">// после выполнения данной строчки, ресурс
// на который указывал ранее y_ptr (int(13)) освободится,
// а на int(42) будут ссылаться оба указателя
</span><span class="n">y_ptr</span> <span class="o">=</span> <span class="n">x_ptr</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">x_ptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">y_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// int(42) освободится лишь при уничтожении последнего ссылающегося
// на него указателя
</span>
</pre>
<p>Также как и <tt class="docutils literal">unique_ptr</tt>, и <tt class="docutils literal">auto_ptr</tt>, данный класс предоставляет методы
<tt class="docutils literal">get()</tt> и <tt class="docutils literal">reset()</tt>.</p>
<pre class="code c++ literal-block"><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">();</span>

<span class="n">ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</pre>
<p>При работе с умным указателем, следует опасаться их создания на лету.
Например, следующий код может привести к утечки памяти.</p>
<pre class="code c++ literal-block"><span class="n">someFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">),</span> <span class="n">getRandomKey</span><span class="p">());</span>
</pre>
<p>Почему? Да потому, что стандарт C++ не определяет порядок вычисления
аргументов. Может случиться так, что сначала выполнится <tt class="docutils literal">new Foo</tt>, затем
<tt class="docutils literal">getRandomKey()</tt> и лишь затем конструктор <tt class="docutils literal">shared_ptr</tt>. Если же функция
<tt class="docutils literal">getRandomKey()</tt> бросит исключение, до конструктора <tt class="docutils literal">shared_ptr</tt> дело не
дойдет, хотя ресурс (объект Foo) был уже выделен.</p>
<p>В случае с <tt class="docutils literal">shared_ptr</tt> есть выход — использовать фабричную функцию
<tt class="docutils literal"><span class="pre">std::make_shared&lt;&gt;</span></tt>, которая создает объект заданного типа и возвращает
<tt class="docutils literal">shared_ptr</tt> указывающий на него.</p>
<pre class="code c++ literal-block"><span class="n">someFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">getRandomKey</span><span class="p">());</span>
</pre>
<p>Почему и как это работает? Очень просто. Как я уже сказал выше, <cite>make_shared</cite>
возвращает <tt class="docutils literal">shared_ptr</tt>. Этот результат является временным объектом, а
стандарт C++ четко декларирует, что временные объекты уничтожаются, в случае
появления исключения.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">К слову, <tt class="docutils literal">new Foo</tt> тоже возвращает временный объект. Однако,
временным является указатель на выделенный ресурс, и в случае исключения —
уничтожится указатель, при этом ресурс останется выделенным.</p>
</div>
</div>
<div class="section" id="weak-ptr">
<h2>weak_ptr</h2>
<p>Этот указатель также, как и <tt class="docutils literal">shared_ptr</tt> начал свое рождение в проекте
<a class="reference external" href="http://www.boost.org/">boost</a>, затем был включен в <a class="reference external" href="http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1">C++ Technical Report 1</a> и, наконец, пришел в
новый стандарт.</p>
<p>Данный класс позволяет разрушить циклическую зависимость, которая, несомненно,
может образоваться при использовании <tt class="docutils literal">shared_ptr</tt>. Предположим, есть
следующая ситуация (переменные-члены не инкапсулированы для упрощения кода)</p>
<pre class="code c++ literal-block"><span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Foo()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Foo()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Bar</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bar()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Bar()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="o">-&gt;</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Как видно, объект <tt class="docutils literal">foo</tt> ссылается на <tt class="docutils literal">bar</tt> и наоборот. Образован цикл,
из-за которого не вызовутся деструкторы объектов. Для того чтобы разорвать
этот цикл, достаточно в классе <tt class="docutils literal">Bar</tt> заменить <tt class="docutils literal">shared_ptr</tt> на <tt class="docutils literal">weak_ptr</tt>.</p>
<div class="hint">
<p class="first admonition-title">Hint</p>
<p class="last">Почему образован цикл? Давайте разберемся. При выходе из блока (в данном
случае функции <tt class="docutils literal">main()</tt>) уничтожаются локальные объекты. Локальным
объектом является <tt class="docutils literal">foo</tt>. При уничтожении <tt class="docutils literal">foo</tt> счетчик ссылок на его
ресурс уменьшится на единицу. Однако, ресурс освобожден не будет, так как
на него есть ссылка со стороны ресурса <tt class="docutils literal">bar</tt>. А на <tt class="docutils literal">bar</tt> есть ссылка
со стороны того же ресурса <tt class="docutils literal">foo</tt>.</p>
</div>
<p><tt class="docutils literal">weak_ptr</tt> не позволяет работать с ресурсом напрямую, но зато обладает
методом <tt class="docutils literal">lock()</tt>, который генерирует <tt class="docutils literal">shared_ptr()</tt>.</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre>
</div>
<div class="section" id="id1">
<h2>Вместо заключения</h2>
<p>Умные указатели — очень удобная и полезная вещь, но я рассмотрел их
поверхностно, лишь их концептуальные части. За полным списком их возможностей
следует обращаться к документации.</p>
<p>Стоит отметить, что рассмотренные мною умные указатели (кроме <tt class="docutils literal">unique_ptr</tt>)
не предназначен для владения массивами. Это связано с тем, что деструктор
вызывает именно <tt class="docutils literal">delete</tt>, а не <tt class="docutils literal">delete[]</tt> (что требуется для массивов).</p>
<p>Для <tt class="docutils literal">unique_ptr</tt> мы имеем дело с предопределенной специализацией для
массивов. Для ее использования необходимо указать <tt class="docutils literal">[]</tt> возле параметра
шаблона. Выглядит это так.</p>
<pre class="code c++ literal-block"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">doSomething</span><span class="p">();</span>
</pre>
<p>Кроме этого, в <a class="reference external" href="http://www.boost.org/">boost</a> есть специальный класс <tt class="docutils literal">shared_array&lt;&gt;</tt>, но он в
новый стандарт включен не был.</p>
</div>

    </div><!-- /.entry-content -->

    <footer>
Tags:        <a href="http://archive.kalnitsky.org/tags/cpp/">#cpp</a>,        <a href="http://archive.kalnitsky.org/tags/lambda/">#lambda</a>    </footer>
  </article>
</div><!-- /.content -->

  <footer id="footer">
    <p>
      <small>Content is licensed under the <br>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
           Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
        </a>
      </small>

    </p><p>
      <small>© 2010-2012
        <a rel="author" href="http://www.kalnitsky.org/about/">Igor Kalnitsky</a>
      </small>
  </p></footer>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" async="" src="./smart-pointers-in-cpp11_files/watch.js"></script><script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter9491932 = new Ya.Metrika({id:9491932, enableAll: true});
        } catch(e) {}
    });
    
    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript>&lt;div&gt;&lt;img src="//mc.yandex.ru/watch/9491932" style="position:absolute; left:-9999px;" alt="" /&gt;&lt;/div&gt;</noscript>
<!-- /Yandex.Metrika counter -->


</body></html>