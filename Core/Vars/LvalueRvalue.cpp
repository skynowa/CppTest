/**
 * \file  LvalueRvalue.cpp
 * \brief
 *
 * \todo
 */


#include <StdStream.h>
#include <StdTest.h>
#include <Stl.h>
//-------------------------------------------------------------------------------------------------
int main(int, char **)
{
   /**
    * Lvalue
    *
    * Данный тип обычно находится с левой стороны выражения.
    * Все переменные имеют lvalue тип. Тоесть то, что мы объявляем явно это lvalue
    * Все перечисленное ниже это lvalue. Также результат функции которая возвращает lvalue будет
    * того же типа.
    *
    * - Выражения, непосредственно обозначающие объект, non-modifiable в случае const-квалификации.
    *   Например, имя переменной, параметра функции и т.п.
    * - Выражения ссылочных типов. non-modifiable в случае const-квалификации. В частности,
    *   результат вызова функций, возвращающих объекты по ссылке; выражения, состоящие из имен
    *   ссылочных переменных; операции преобразования к ссылочному типу и т.д.
    * - Результат встроенной операции разыменования (*) — lvalue указуемого типа; non-modifiable
        в случае const-квалификации
    * - Результат встроенных префиксных операций ++, --
    * - Имя функции — non-modifiable lvalue; может быть преобразовано к rvalue
    *   «указатель на функцию»
    * - Имя массива — non-modifiable lvalue; может быть преобразовано к rvalue
    *   «указатель на первый элемент массива»
    * - Строковые литералы — non-modifiable lvalue; может быть преобразовано к rvalue
    *   «указатель на char/wchar_t»
    */

    // а - именованная переменная это lvalue
    int a;
    STD_UNUSED(a);

    // переменная с модификатором const также lvalue
    const char b = 'a';
    STD_UNUSED(b);

    // указатель не является исключением.
    int* ptr{};
    STD_UNUSED(ptr);

    // функция возвращает lvalue
    struct Foo
    {
        int& foo(int k)
        {
            static int b = k + 1;
            return b;
        }
    };


   /**
    * Rvalue
    *
    * Встречается с правой стороны выражения. Все то что не имеет имени (выражения) это rvalue.
    * Объект близкий к концу жизни(если речь к примеру идет о функции) также имеет тип rvalue.
    * Также результат функции, которая не возвращает ссылку это rvalue.
    *
    * - Выражения, обозначающие временные объекты. В частности, результат вызова функций,
    *   возвращающих объекты не по ссылке; результат встроенных операций +, -. *, / и т.п.;
        явное создание временной переменной int() или C();
        преобразования не к ссылочным типам и т.д.
    * - Результат встроенной операции взятия адреса (&) — rvalue типа указатель.
    * - Результат встроенных постфиксных операций ++, --.
    * - Литералы за исключением строковых.
    * - Константы перечислений.
    */

    // результат выражения 3 + 5 есть rvalue
    Foo f;
    f.foo(3 + 5);

    // ошибка 7 - это rvalue, невозможно создать ссылку на rvalue
#if 0
    int i = &7;
    STD_UNUSED(i);
#endif

    // true is rvalue
    bool c = true;
    STD_UNUSED(c);

    // функция возвращает rvalue
    struct Bar
    {
        int bar()
        {
            return 5;
        }
    };

    return EXIT_SUCCESS;
}
//-------------------------------------------------------------------------------------------------


#if OUTPUT



#endif
